<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emerald Christmas - PC Ultimate</title>
    <style>
        /* CSS ‰∏é ÊâãÊú∫Áâà 99% Áõ∏ÂêåÔºåÂè™ÊòØÊ≤°Êúâ touch-action ÈôêÂà∂ */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
        body { margin: 0; overflow: hidden; background-color: #011a0e; background: radial-gradient(circle at center, #022414 0%, #000803 100%); font-family: 'Times New Roman', serif; user-select: none; color: #d4af37; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #fireworks-canvas { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 2; pointer-events: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100vh; z-index: 5; pointer-events: none; display: flex; flex-direction: column; align-items: center; padding-top: 6vh; box-sizing: border-box; transition: opacity 0.8s ease; }
        h1 { font-family: 'Cinzel', serif; color: #fceea7; font-size: min(5vw, 72px); margin: 0; font-weight: 700; letter-spacing: 10px; text-shadow: 0 0 30px rgba(212, 175, 55, 0.8); background: linear-gradient(to bottom, #fffdf0, #d4af37); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-align: center; padding: 0 20px; }
        #immersive-btn { position: absolute; top: 30px; right: 30px; z-index: 60; background: rgba(0, 10, 5, 0.4); border: 1px solid #d4af37; color: #d4af37; width: 50px; height: 50px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 24px; transition: 0.3s; backdrop-filter: blur(5px); }
        #immersive-btn:hover { background: #d4af37; color: #011a0e; }
        body.clean-mode #ui-layer, body.clean-mode #webcam-wrapper { opacity: 0 !important; pointer-events: none; }
        .fullscreen-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100vh; background: rgba(1, 15, 8, 0.96); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #d4af37; transition: opacity 0.8s ease; backdrop-filter: blur(15px); }
        .setup-container { width: 500px; padding: 50px; border: 1px solid rgba(212, 175, 55, 0.4); background: linear-gradient(135deg, rgba(20, 40, 30, 0.85), rgba(5, 15, 10, 0.95)); border-radius: 4px; text-align: center; box-shadow: 0 0 80px rgba(0, 0, 0, 0.9); }
        .setup-group { margin-bottom: 30px; text-align: left; }
        .setup-label { display: block; margin-bottom: 12px; font-family: 'Cinzel', serif; font-size: 14px; letter-spacing: 3px; color: #a3cfa3; }
        .setup-input { width: 100%; padding: 15px; background: rgba(0, 0, 0, 0.4); border: 1px solid #2a4a3a; color: #fff; font-size: 18px; border-radius: 2px; box-sizing: border-box; }
        .file-btn { border: 1px solid rgba(212, 175, 55, 0.4); color: #d4af37; background: rgba(0,20,10,0.6); padding: 16px; width: 100%; font-size: 14px; letter-spacing: 3px; border-radius: 2px; cursor: pointer; }
        .action-btn { background: linear-gradient(to right, #bf953f, #fcf6ba, #bf953f); color: #001005; border: none; padding: 20px 60px; font-family: 'Cinzel', serif; font-size: 20px; letter-spacing: 6px; margin-top: 20px; font-weight: 700; border-radius: 2px; cursor: pointer; box-shadow: 0 0 40px rgba(212, 175, 55, 0.3); }
        #webcam-wrapper { position: absolute; bottom: 40px; left: 40px; width: 240px; height: 180px; z-index: 50; border: 2px solid #d4af37; background: rgba(0, 10, 5, 0.8); box-shadow: 0 0 30px rgba(212, 175, 55, 0.2); transition: opacity 0.8s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 4px; overflow: hidden; }
        #webcam-wrapper::after { content: 'GESTURE CONTROL'; position: absolute; bottom: 5px; width: 100%; text-align: center; color: #d4af37; font-size: 10px; letter-spacing: 3px; text-shadow: 0 0 5px #000; }
        #webcam-preview { width: 100%; height: 100%; object-fit: cover; opacity: 0.9; transform: scaleX(-1); }
        .spinner { width: 60px; height: 60px; border: 4px solid rgba(212, 175, 55, 0.1); border-top: 4px solid #d4af37; border-radius: 50%; animation: spin 1s infinite linear; margin-bottom: 30px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loader-text { font-family: 'Cinzel', serif; font-size: 16px; color: #d4af37; letter-spacing: 4px; text-align: center; line-height: 1.8; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/", "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm" } }
    </script>
</head>
<body>
    <button id="immersive-btn">üëÅÔ∏è</button>
    <div id="system-loader" class="fullscreen-overlay" style="z-index: 200;"><div class="spinner" id="sys-spinner"></div><div class="loader-text" id="sys-status">System Initializing...</div><button id="init-btn" class="action-btn" onclick="requestPermissionAndNext()" style="display:none;">Initialize</button></div>
    <div id="setup-screen" class="fullscreen-overlay" style="z-index: 150; display: none;"><div class="setup-container"><h2 style="font-family: 'Cinzel'; margin: 0 0 30px 0; color: #fceea7; font-size: 28px;">Configuration</h2><div class="setup-group"><label class="setup-label">Title</label><input type="text" id="greeting-input" class="setup-input" placeholder="Merry Christmas" value="Merry Christmas"></div><div class="setup-group"><label class="setup-label">Photos (UHD)</label><div class="file-input-wrapper"><button class="file-btn" id="photo-btn" onclick="document.getElementById('photo-input').click()">Select High-Res Images</button><input type="file" id="photo-input" multiple accept="image/*" style="display: none;" onchange="handleSetupFiles(this, 'photo-btn')"></div></div><div class="setup-group"><label class="setup-label">Audio</label><div class="file-input-wrapper"><button class="file-btn" id="music-btn" onclick="document.getElementById('music-input').click()">Select Audio File</button><input type="file" id="music-input" accept="audio/*" style="display: none;" onchange="handleSetupFiles(this, 'music-btn')"></div></div><button class="action-btn" onclick="finishSetupAndReveal()">Ignite</button></div></div>
    <div id="canvas-container"></div><canvas id="fireworks-canvas"></canvas><div id="ui-layer"><h1 id="main-title">Merry Christmas</h1></div>
    <div id="webcam-wrapper" style="opacity: 0;"><video id="webcam" autoplay muted playsinline style="position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; z-index: -1;"></video><canvas id="webcam-preview"></canvas></div>

    <script type="module">
        import * as THREE from 'three'; import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js'; import { RenderPass } from 'three/addons/postprocessing/RenderPass.js'; import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js'; import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- PC CONFIG ---
        const CONFIG = { colors: { bg: 0x011a0e, gold: 0xd4af37, leafGreen: 0x0b3d18, trunkBrown: 0x3d2314, lights: [0xff3333, 0xffd700, 0x3366ff, 0xaa33cc, 0xffffff] }, 
                         particles: { count: 4500, treeHeight: 28, treeRadius: 10 }, // 4500 Á≤íÂ≠ê
                         snow: { count: 2000, speed: 3.5 }, 
                         camera: { z: 50 },
                         pixelRatio: Math.min(window.devicePixelRatio, 3.0), anisotropy: 16, camWidth: 1280, camHeight: 720 }; 

        // --- GLOBAL LOGIC ---
        window.userPhotos = []; window.userAudio = null; window.isCameraReady = false; let globalStream = null;
        let grabTimer = null; let isGestureLocked = false; let hasTriggeredGrab = false; 
        let scene, camera, renderer, composer, mainGroup; let clock = new THREE.Clock(); let particleSystem = []; let snowSystem; let handLandmarker, video, webcamCanvas, webcamCtx; let raycaster = new THREE.Raycaster(); let mouse = new THREE.Vector2(); let lightMaterials = [];
        const STATE = { mode: 'TREE', focusTarget: null, hand: { detected: false, x: 0, y: 0 }, rotation: { x: 0, y: 0 }, photoIndex: -1, hasExpandedOnce: false, interactionEnabled: false };

        // --- FIREWORKS (Same as Mobile) ---
        const fwCanvas = document.getElementById('fireworks-canvas'); const fwCtx = fwCanvas.getContext('2d'); let fwWidth, fwHeight, fwScale; let fParticles = []; let smokes = [];
        const glowCanvas = document.createElement('canvas'); glowCanvas.width = 32; glowCanvas.height = 32; const gCtx = glowCanvas.getContext('2d'); const gradG = gCtx.createRadialGradient(16, 16, 0, 16, 16, 16); gradG.addColorStop(0, 'rgba(255,255,255,1)'); gradG.addColorStop(1, 'rgba(255,255,255,0)'); gCtx.fillStyle = gradG; gCtx.fillRect(0,0,32,32);
        const smokeCanvas = document.createElement('canvas'); smokeCanvas.width=128; smokeCanvas.height=128; const smCtx = smokeCanvas.getContext('2d'); const smGrad = smCtx.createRadialGradient(64,64,0,64,64,64); smGrad.addColorStop(0,'rgba(160,160,170,0.8)'); smGrad.addColorStop(1,'rgba(80,80,90,0)'); smCtx.fillStyle=smGrad; smCtx.fillRect(0,0,128,128);
        const random = (min,max) => Math.random()*(max-min)+min; const SPEED_MOD=0.7;
        class Smoke { constructor(x,y){this.x=x;this.y=y;this.vx=random(-0.25,0.25)*fwScale*SPEED_MOD;this.vy=random(-0.15,0.15)*fwScale*SPEED_MOD;this.size=random(20,45)*fwScale;this.life=random(60,100)/SPEED_MOD;this.maxLife=this.life;this.alphaStart=random(0.15,0.3);} update(){this.x+=this.vx;this.y+=this.vy;this.size+=0.2;this.life--;return this.life>0;} draw(){let a=this.alphaStart*Math.pow(this.life/this.maxLife,2);if(a>0.005){fwCtx.save();fwCtx.globalAlpha=a;fwCtx.drawImage(smokeCanvas,this.x-this.size,this.y-this.size,this.size*2,this.size*2);fwCtx.restore();}}}
        class Spark { constructor(x,y,vx,vy,isG){this.x=x;this.y=y;this.isG=isG;this.vx=vx*SPEED_MOD;this.vy=vy*SPEED_MOD;this.life=random(40,80)/SPEED_MOD;this.maxLife=this.life;this.size=random(1,3)*fwScale;} update(){this.vx*=0.96;this.vy+=0.06*fwScale*SPEED_MOD;this.x+=this.vx;this.y+=this.vy;this.life--;return this.life>0;} draw(){fwCtx.fillStyle=`rgba(255,220,150,${this.life/this.maxLife})`;fwCtx.beginPath();fwCtx.arc(this.x,this.y,this.size,0,Math.PI*2);fwCtx.fill();}}
        class Shell { constructor(x,y,tx,ty,t,d){this.x=x;this.y=y;const g=0.15*fwScale*SPEED_MOD;const dy=y-ty;const vy=Math.sqrt(2*g*dy);const t_time=vy/g;const dx=tx-x;this.vx=dx/t_time;this.vy=-vy;this.gravity=g;this.type=t;this.depth=d;this.dead=false;} update(){this.vy+=this.gravity;this.x+=this.vx;this.y+=this.vy;if(Math.random()>0.7)smokes.push(new Smoke(this.x,this.y));if(this.vy>=0){this.dead=true;explode(this.x,this.y,this.type,this.depth);}return !this.dead;} draw(){fwCtx.drawImage(glowCanvas,this.x-6*fwScale,this.y-6*fwScale,12*fwScale,12*fwScale);}}
        function explode(x,y,type,depth){ const count=type==='willow'?80:15; for(let i=0;i<count;i++){ const a=random(0,Math.PI*2); const s=random(2,22)*fwScale*depth; fParticles.push(new Spark(x,y,Math.cos(a)*s,Math.sin(a)*s,type==='willow')); } }
        function resizeFireworks(){ fwWidth=fwCanvas.width=window.innerWidth; fwHeight=fwCanvas.height=window.innerHeight; fwScale=Math.min(fwWidth,fwHeight)/900; }
        function triggerFireworks(){ const cx=fwWidth/2; for(let i=0;i<5;i++) setTimeout(()=>{ fParticles.push(new Shell(cx,fwHeight,cx+(i-2)*100*fwScale,fwHeight*0.3,'willow',1.0)); }, i*200); }

        // --- INIT ---
        window.onload = () => {
            initThree(); createSceneContent(); resizeFireworks(); setupInteraction(); animate();
            const status = document.getElementById('sys-status'); const btn = document.getElementById('init-btn'); const spinner = document.getElementById('sys-spinner');
            setTimeout(() => { status.innerHTML = "Enable Camera for<br>Precision Control"; spinner.style.display = 'none'; btn.style.display = 'block'; }, 1000);
            const toggleBtn = document.getElementById('immersive-btn'); toggleBtn.addEventListener('click', ()=>document.body.classList.toggle('clean-mode'));
            window.addEventListener('keydown', (e) => { if(e.key.toLowerCase() === 'f') document.body.classList.toggle('clean-mode'); if(e.key.toLowerCase() === 'r') location.reload(); });
        };
        window.requestPermissionAndNext = async () => {
            document.getElementById('init-btn').style.display='none'; document.getElementById('sys-spinner').style.display='block'; document.getElementById('sys-status').innerText="Connecting...";
            try { globalStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: { width: { ideal: CONFIG.camWidth }, height: { ideal: CONFIG.camHeight } } }); window.isCameraReady = true; if(initMediaPipe) initMediaPipe(globalStream); } 
            catch(e){ window.isCameraReady = false; document.getElementById('sys-status').innerText="Camera Unavailable. Mouse Active."; }
            setTimeout(() => { document.getElementById('system-loader').style.display = 'none'; document.getElementById('setup-screen').style.display = 'flex'; }, 800);
        };
        window.handleSetupFiles = (input, btnId) => { if(input.files.length){ document.getElementById(btnId).innerText=`${input.files.length} Loaded`; if(btnId==='photo-btn') { window.userPhotos=[]; Array.from(input.files).forEach(f=>{ const r=new FileReader(); r.onload=e=>{ const i=new Image(); i.src=e.target.result; i.onload=()=>{ window.userPhotos.push({src:e.target.result, aspect:i.width/i.height}); }}; r.readAsDataURL(f); }); } else window.userAudio=input.files[0]; }};
        window.finishSetupAndReveal = () => {
            document.getElementById('main-title').innerText = document.getElementById('greeting-input').value.trim() || "Merry Christmas";
            if(window.userPhotos.length) window.userPhotos.forEach(p=>addPhotoParticle(p.src, p.aspect));
            if(window.userAudio) { const a = new Audio(URL.createObjectURL(window.userAudio)); a.loop=true; a.volume=0.5; a.play().catch(()=>{}); }
            document.getElementById('setup-screen').style.opacity=0; setTimeout(()=>{ document.getElementById('setup-screen').style.display='none'; setTimeout(()=>STATE.interactionEnabled=true,1000); if(window.isCameraReady) document.getElementById('webcam-wrapper').style.opacity=1; },800);
        };

        // --- 3D LOGIC ---
        async function initMediaPipe(stream) {
            video = document.getElementById('webcam'); webcamCanvas = document.getElementById('webcam-preview'); webcamCtx = webcamCanvas.getContext('2d');
            webcamCanvas.width = 320; webcamCanvas.height = 240;
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, { baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" }, runningMode: "VIDEO", numHands: 1 });
            video.srcObject = stream; video.onloadedmetadata = () => { video.play().catch(e=>{}); }; video.addEventListener("loadeddata", predictWebcam);
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if(video.paused && window.isCameraReady) video.play().catch(()=>{});
            // PCÁâà ‰∏çÈïúÂÉè (remove scale -1,1)
            if(video.readyState >= 2) { webcamCtx.drawImage(video, 0, 0, webcamCanvas.width, webcamCanvas.height); }
            if(video.currentTime !== lastVideoTime && handLandmarker) {
                lastVideoTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, performance.now());
                if(result.landmarks.length > 0 && STATE.interactionEnabled) {
                    STATE.hand.detected = true; const lm = result.landmarks[0];
                    webcamCtx.fillStyle = "#d4af37"; lm.forEach(p => { webcamCtx.beginPath(); webcamCtx.arc(p.x*320, p.y*240, 2, 0, 2*Math.PI); webcamCtx.fill(); });
                    
                    const wrist=lm[0]; const tips=[lm[8],lm[12],lm[16],lm[20]]; let avgDist=0; tips.forEach(t=>avgDist+=Math.hypot(t.x-wrist.x, t.y-wrist.y)); avgDist/=4;
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

                    if(STATE.mode === 'FOCUS') {
                        if(avgDist > 0.4) { if(grabTimer) { clearTimeout(grabTimer); grabTimer=null; } isGestureLocked=false; hasTriggeredGrab=false; changeState('SCATTER'); }
                    } else if(STATE.mode === 'SCATTER') {
                        if(pinchDist < 0.05 && !isGestureLocked && !hasTriggeredGrab) {
                            const photos = particleSystem.filter(p => p.type === 'PHOTO');
                            if(photos.length) { 
                                STATE.focusTarget = photos[Math.floor(Math.random()*photos.length)].mesh; STATE.mode='FOCUS'; 
                                isGestureLocked=true; hasTriggeredGrab=true;
                                if(grabTimer) clearTimeout(grabTimer); grabTimer = setTimeout(()=>{ isGestureLocked=false; grabTimer=null; }, 3000);
                            }
                        } else if(avgDist < 0.25 && !isGestureLocked) changeState('TREE');
                        if(pinchDist > 0.1) hasTriggeredGrab=false;
                    } else { if(avgDist > 0.4 && !isGestureLocked) changeState('SCATTER'); }
                    STATE.hand.x = (lm[9].x - 0.5) * 2; STATE.hand.y = (lm[9].y - 0.5) * 2;
                } else STATE.hand.detected = false;
            }
            requestAnimationFrame(predictWebcam);
        }

        function initThree() {
            const container = document.getElementById('canvas-container'); scene = new THREE.Scene(); scene.background = new THREE.Color(CONFIG.colors.bg); scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.012);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.set(0,3,CONFIG.camera.z);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(CONFIG.pixelRatio); renderer.toneMapping = THREE.ReinhardToneMapping; renderer.toneMappingExposure = 2.4; container.appendChild(renderer.domElement);
            mainGroup = new THREE.Group(); mainGroup.position.y = -2.0; scene.add(mainGroup);
            composer = new EffectComposer(renderer); composer.addPass(new RenderPass(scene, camera)); composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));
            scene.add(new THREE.AmbientLight(0xffffff, 0.5)); const s=new THREE.SpotLight(0xffd966, 2500); s.position.set(40,50,40); scene.add(s); scene.add(new THREE.DirectionalLight(0xd4af37, 0.8));
        }

        function createSceneContent() {
            const leafMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.leafGreen, metalness: 0.1, roughness: 0.8, emissive: 0x021204, emissiveIntensity: 0.2 });
            const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4); const sphereGeo = new THREE.SphereGeometry(0.35, 32, 32);
            CONFIG.colors.lights.forEach(c => lightMaterials.push(new THREE.MeshStandardMaterial({ color: c, emissive: c, emissiveIntensity: 1.0, metalness: 0.8, roughness: 0.2 })));
            
            for(let i=0; i<CONFIG.particles.count; i++) {
                let mesh, type; if(Math.random()<0.15) { mesh=new THREE.Mesh(sphereGeo, lightMaterials[Math.floor(Math.random()*lightMaterials.length)]); type='LIGHT'; } else { mesh=new THREE.Mesh(boxGeo, leafMat); type='LEAF'; }
                const s=0.3+Math.random()*0.7; mesh.scale.set(s,s,s); mainGroup.add(mesh); particleSystem.push(new Particle(mesh, type));
            }
            const sm = new THREE.MeshStandardMaterial({color:0xffdd88,emissive:0xffaa00,emissiveIntensity:2}); const star=new THREE.Mesh(new THREE.OctahedronGeometry(1.5,0), sm); star.position.set(0,CONFIG.particles.treeHeight/2+1,0); star.add(new THREE.PointLight(0xffaa00,200,20)); mainGroup.add(star);
            
            const pos=[], vel=[]; for(let i=0;i<CONFIG.snow.count;i++){ pos.push((Math.random()-0.5)*80, (Math.random()-0.5)*80+10, (Math.random()-0.5)*80); vel.push(0, -(Math.random()*0.5+0.5)*CONFIG.snow.speed, 0); }
            const geo = new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3)); geo.userData={vel:vel};
            const sc = document.createElement('canvas'); sc.width=32;sc.height=32; const sctx=sc.getContext('2d'); const sg=sctx.createRadialGradient(16,16,0,16,16,16); sg.addColorStop(0,'rgba(255,255,255,1)'); sg.addColorStop(1,'rgba(255,255,255,0)'); sctx.fillStyle=sg; sctx.fillRect(0,0,32,32);
            snowSystem = new THREE.Points(geo, new THREE.PointsMaterial({size:0.6, map:new THREE.CanvasTexture(sc), transparent:true, opacity:0.8, depthWrite:false, blending:THREE.AdditiveBlending})); scene.add(snowSystem);
        }

        function addPhotoParticle(src, aspect) {
            const tex = new THREE.TextureLoader().load(src); tex.colorSpace = THREE.SRGBColorSpace; tex.minFilter=THREE.LinearFilter; tex.generateMipmaps=false; tex.anisotropy=CONFIG.anisotropy;
            const w = 1.2*aspect; const frame = new THREE.Mesh(new THREE.BoxGeometry(w+0.2, 1.4, 0.05), new THREE.MeshStandardMaterial({color:CONFIG.colors.gold}));
            const photo = new THREE.Mesh(new THREE.PlaneGeometry(w, 1.2), new THREE.MeshBasicMaterial({map:tex})); photo.position.z=0.03;
            const g = new THREE.Group(); g.add(frame, photo); mainGroup.add(g); particleSystem.push(new Particle(g, 'PHOTO'));
        }

        class Particle {
            constructor(mesh, type) {
                this.mesh = mesh; this.type = type; this.baseScale = mesh.scale.x; this.posTree = new THREE.Vector3(); this.posScatter = new THREE.Vector3();
                const h = CONFIG.particles.treeHeight; const t = Math.pow(Math.random(), 1.2); const y = (t*h)-h/2; const r = CONFIG.particles.treeRadius*(1-t)*(0.3+0.7*Math.sqrt(Math.random())); const a = t*80*Math.PI + Math.random()*Math.PI*2;
                this.posTree.set(Math.cos(a)*r, y, Math.sin(a)*r);
                const rs = 12+Math.random()*20; const th = Math.random()*Math.PI*2; const ph = Math.acos(2*Math.random()-1);
                this.posScatter.set(rs*Math.sin(ph)*Math.cos(th), rs*Math.sin(ph)*Math.sin(th), rs*Math.cos(ph));
                this.spin = new THREE.Vector3((Math.random()-0.5)*6, (Math.random()-0.5)*6, (Math.random()-0.5)*6);
                if(type==='TRUNK') this.posTree.set(0, y-2, 0); 
            }
            update(dt, mode, targetMesh) {
                let target = this.posTree; let s = this.baseScale;
                if(mode==='SCATTER') { target=this.posScatter; this.mesh.rotation.x+=this.spin.x*dt; this.mesh.rotation.y+=this.spin.y*dt; this.mesh.rotation.z+=this.spin.z*dt; if(this.type==='PHOTO'){s=this.baseScale*2.5; this.mesh.rotation.x*=0.9; this.mesh.rotation.y*=0.9; this.mesh.rotation.z*=0.9;} }
                else if(mode==='FOCUS') {
                    if(this.mesh===targetMesh) { const inv = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert(); target = new THREE.Vector3(0,2,35).applyMatrix4(inv); this.mesh.lookAt(camera.position); s=4.5; }
                    else { target=this.posScatter; s=(this.type==='PHOTO')?this.baseScale*2:this.baseScale*0.8; }
                } else { this.mesh.rotation.x*=0.95; this.mesh.rotation.z*=0.95; }
                this.mesh.position.lerp(target, 2.5*dt); this.mesh.scale.lerp(new THREE.Vector3(s,s,s), 4*dt);
            }
        }

        function changeState(n) { if(STATE.mode===n)return; if(n==='SCATTER') STATE.hasExpandedOnce=true; if(n==='TREE'&&STATE.mode==='SCATTER'&&STATE.hasExpandedOnce) triggerFireworks(); STATE.mode=n; STATE.focusTarget=null; }
        function setupInteraction() { 
            window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); resizeFireworks(); });
            window.addEventListener('mousedown', e=>{ if(!STATE.interactionEnabled)return; if(STATE.mode==='TREE')changeState('SCATTER'); else if(STATE.mode==='SCATTER') { const p = particleSystem.filter(x=>x.type==='PHOTO'); if(p.length) { STATE.mode='FOCUS'; STATE.focusTarget=p[Math.floor(Math.random()*p.length)].mesh; } } else changeState('SCATTER'); });
        }
        function animate() { requestAnimationFrame(animate); const dt=clock.getDelta(); const el=clock.elapsedTime; fwCtx.clearRect(0,0,fwWidth,fwHeight); fwCtx.globalCompositeOperation='lighter'; let i=fParticles.length; while(i--){if(!fParticles[i].update())fParticles.splice(i,1);else fParticles[i].draw();} let j=smokes.length; while(j--){if(!smokes[j].update())smokes.splice(j,1);else smokes[j].draw();} lightMaterials.forEach(m=>m.emissiveIntensity=0.5+(Math.sin(el*2.5)+1)*0.75); if(snowSystem){ const p=snowSystem.geometry.attributes.position.array; const v=snowSystem.geometry.userData.vel; for(let k=0;k<CONFIG.snow.count;k++){ p[k*3+1]+=v[k*3+1]*dt*5; if(p[k*3+1]<-20)p[k*3+1]=40; } snowSystem.geometry.attributes.position.needsUpdate=true; } if(STATE.mode==='SCATTER'){ STATE.rotation.y+=0.4*dt; STATE.rotation.x*=0.95; } else if(STATE.mode==='TREE'){ STATE.rotation.y+=0.3*dt; STATE.rotation.x*=0.95; } mainGroup.rotation.x=STATE.rotation.x; mainGroup.rotation.y=STATE.rotation.y; particleSystem.forEach(p=>p.update(dt, STATE.mode, STATE.focusTarget)); composer.render(); }
    </script>
</body>
</html>
